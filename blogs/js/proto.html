<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 原型篇 | FXburning</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="FXburning's blogs">
    
    <link rel="preload" href="/FXburning/assets/css/0.styles.981fd464.css" as="style"><link rel="preload" href="/FXburning/assets/js/app.a5785852.js" as="script"><link rel="preload" href="/FXburning/assets/js/2.ee1c7fd8.js" as="script"><link rel="preload" href="/FXburning/assets/js/9.4187d263.js" as="script"><link rel="prefetch" href="/FXburning/assets/js/10.d2ba6420.js"><link rel="prefetch" href="/FXburning/assets/js/11.586869d4.js"><link rel="prefetch" href="/FXburning/assets/js/12.c854fb22.js"><link rel="prefetch" href="/FXburning/assets/js/13.261e78fd.js"><link rel="prefetch" href="/FXburning/assets/js/14.34a6478e.js"><link rel="prefetch" href="/FXburning/assets/js/3.7e6d5160.js"><link rel="prefetch" href="/FXburning/assets/js/4.24ff827e.js"><link rel="prefetch" href="/FXburning/assets/js/5.4a646df1.js"><link rel="prefetch" href="/FXburning/assets/js/6.7a0f80e6.js"><link rel="prefetch" href="/FXburning/assets/js/7.77050805.js"><link rel="prefetch" href="/FXburning/assets/js/8.c68a3c9e.js">
    <link rel="stylesheet" href="/FXburning/assets/css/0.styles.981fd464.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FXburning/" class="home-link router-link-active"><!----> <span class="site-name">FXburning</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/FXburning/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/FXburning/blogs/" class="nav-link router-link-active">
  Blogs
</a></div><div class="nav-item"><a href="/FXburning/other/" class="nav-link">
  Others
</a></div><div class="nav-item"><a href="/FXburning/FXburning/" class="nav-link">
  About
</a></div><div class="nav-item"><a href="https://github.com/FXburning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/FXburning/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/FXburning/blogs/" class="nav-link router-link-active">
  Blogs
</a></div><div class="nav-item"><a href="/FXburning/other/" class="nav-link">
  Others
</a></div><div class="nav-item"><a href="/FXburning/FXburning/" class="nav-link">
  About
</a></div><div class="nav-item"><a href="https://github.com/FXburning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-原型篇"><a href="#javascript-原型篇" class="header-anchor">#</a> JavaScript 原型篇</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>对于每一位前端开发人员来说 <code>JavaScript</code> 语言本身是相当重要的，掌握好这一门语言就是我们的立足之本。但是对于语言本身的一些难点，可能我们每次都掌握的不扎实，不能把他挖深了。这一节就针对<strong>原型与原型链</strong>这一部分内容进行深入的彻底学习，一劳永逸。</p> <p>本文我会尽量使用通俗易懂的方式阐述，并且加杂着<strong>图片</strong>辅助大家理解。我会从原型本身的定义讲起直到前端社区中对<strong>原型与原型链</strong>的经典使用，由潜入深的学习这一块知识。将知识<strong>体系化，实践化</strong>。相信通过这样，大家都可以一次性的学会<strong>原型与原型链</strong>。</p> <h2 id="为什么需要原型"><a href="#为什么需要原型" class="header-anchor">#</a> 为什么需要原型</h2> <p>在传统的面向对象语言比如 <code>java</code> 中，使用 <code>class</code> 关键字定义一个类，我们可以创建一个类的实例对象。</p> <p>但是在我们熟悉的 <code>javascript</code> 这门语言中其实并没有<strong>类</strong>这一概念，它是使用了一种不常用的方式来实现面向对象这一特性，这种方式就是<strong>原型</strong>。</p> <p>所以原型是 <code>javascript</code> 的作者在设计这门语言的时候为了支持面向对象的选择。</p> <h2 id="prototype-原型对象-是什么"><a href="#prototype-原型对象-是什么" class="header-anchor">#</a> prototype(原型对象)是什么</h2> <p><code>javascript</code> 规定，<strong>每一个函数</strong>都有一个 <code>prototype</code> 属性，指向<strong>另一个对象(原型对象)</strong>。</p> <p>这个<strong>原型对象</strong>上的所有属性和方法都会被它的构造器函数的<strong>实例</strong>继承。</p> <p>我们来创建一个函数，并且打印一下它的 <code>prototype</code> 属性一探究竟：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>浏览器中执行这段代码，返回结果为：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/148b97b066114eb18afdc770acd00657~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>首先这确实是一个<strong>对象</strong>，它有两个属性，我们先看 <code>constructor</code> 这一属性。它的值是一个函数，看起来就是 <code>Person</code> 本身，来验证一下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>果然是它本身。所以说 <code>Person</code> 这一函数其实就是<strong>它的原型对象的构造器函数</strong>。</p> <p>我们再来看这个构造函数的实例对象会不会继承原型对象上的方法。
首先我会给 <code>Person</code> 的原型对象添加一个 <code>name</code> 属性和 <code>getName</code> 方法，然后访问它的实例对象上有没有继承对应的属性和方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Person 原型对象上的 name 属性'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样在浏览器中看执行结果：</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50eb82d9e43b4e179b9ab826ab2a9817~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>可以看到得到了预期的结果，这样也就解释了<strong>什么是原型对象</strong>并且<strong>验证了继承这一特性</strong>。</p> <h2 id="proto"><a href="#proto" class="header-anchor">#</a> __proto__</h2> <p>上面我们已经知道了<strong>每一个函数都有一个原型对象</strong>，并且<strong>构造函数的实例对象会继承这个原型对象的属性和方法</strong>。</p> <p>那么这个实例对象就肯定跟构造函数的原型对象之间存在着某种<strong>联系</strong>。这一个联系表现在实例对象的 <code>__proto__</code> 这一属性上。</p> <p>也就是说<strong>实例对象</strong>的 <code>__proto__</code> <strong>这一属性的属性值指向它的构造函数的原型对象</strong>。我们再来加以验证：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到浏览器的执行结果为 <code>true</code>：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2fd8cce37a4acb843f145c4c5fe7f3~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p><strong>在讲解原型链之前，我们先来做一个铺垫：</strong></p> <p>其实，对于<strong>每一个对象</strong>来说，它都有 <code>__proto__</code> 这一属性，注意这里的对象是<strong>泛指的</strong>。也就是说，对于<strong>数组</strong>、<strong>正则</strong>、<strong>日期</strong>、<strong>函数</strong>等对象都具有这一属性。因为函数其实也是一个对象，在 <code>javascript</code> 中，万物皆是对象。</p> <p>我们来验证一下函数具有这一属性：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以在浏览器中看到：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf9c773818c4fd1bd4947d42c050786~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>我们先不管这是什么，起码我们已经验证了<strong>函数</strong>、<strong>普通对象等</strong>都具有 <code>__proto__</code> 这一属性，这对后面介绍原型链具有很大帮助。</p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>了解原型之后，也就到了一个最重要的环节——<strong>原型链</strong>。</p> <p><code>javascript</code> 语言在原型的基础上通过<strong>链表</strong>这一数据结构将原型<strong>成链</strong>，<strong>成环</strong>。搞清楚这一特性后，可以对语言有更深层次的认知，使用层面上也会让你变得游刃有余。</p> <p>先来将之前所述中重要的几点做一个总结：</p> <ul><li>每一个函数都有一个 <code>prototype</code> 属性，指向它的原型对象。</li> <li>这个原型对象上的所有属性和方法都会被它的构造器函数的实例对象继承。</li> <li>任一对象的 <code>__proto__</code> 属性都指向它的构造器函数的原型对象。</li></ul> <h3 id="数组的原型链"><a href="#数组的原型链" class="header-anchor">#</a> 数组的原型链</h3> <p>我们先来拿<strong>数组</strong>举个栗子。数组也是对象类型的数据，所以每一个数组都具有 <code>__proto__</code> 属性，我们来验证一下上面的第三条：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>其实，这是因为上面的数组声明方式其实相当于：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所以，<code>arr</code> 是构造函数 <code>Array</code> 的一个实例对象并且我们已经验证了第三点。即它的 <code>__proto__</code> 属性指向 <code>Array</code> 的原型对象。</p> <p>那么我们就可以根据第二点得出这一数组会继承 <code>Array</code> 的原型对象上的属性和方法，我们先来看一下 <code>Array.prototype</code> 上面究竟有什么属性和方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/063b94c5873447c98211c425be2d7557~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>这里只是截取了部分属性方法，我们看到了熟悉的 <code>concat</code>、<code>filter</code>、<code>indexOf</code> 等等方法，并且看到了一个属性 <code>length</code> 。</p> <p>看到这里大家就懂了为什么我们只是声明了一个数组，为什么它上面就有那么多的属性和方法呢。其实这都归功于 <code>javascript</code> 本身的<strong>原型与原型链</strong>机制。</p> <p>到这里，我还迟迟没有推出<strong>原型链</strong>这一特性，接下来，就让我们沿着数组的原型链去一探究竟。</p> <p>我们知道 <code>arr.__proto__</code> 其实就是 <code>Array.prototype</code> 。那么 <code>arr.__proto__.__proto__</code> 就应该是 <code>Array.prototype.__proto__</code> 。</p> <p>我们来分析一下 <code>Array.prototype.__proto__</code>：</p> <ol><li>首先 <code>Array.prototype</code> 可以看做数组的原型对象，那么它就是一个拥有键值对的对象。</li> <li>又有一个简单对象的 <code>__proto__</code> 属性指向 <code>Object.prototype</code> 。</li> <li>可以猜测 <code>Array.prototype.__proto__</code> 就是 <code>Object.prototype</code> 。</li></ol> <p>验证一下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>由于继承的传递性，可以得到每一个数组也都拥有 <code>Obejct.prototype</code> 这一原型对象上的属性和方法。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/656d146d903b4f9f8262665f5c7e63d4~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>我想当你看到 <code>toString</code>、<code>valueOf</code> 这些方法的时候你就已经一目了然了，原来一个对象上的这些方法都继承来自 <code>Obejct.prototype</code>，不过有些原型对象上的这些方法被改写了而已。</p> <p>当我们都以为一切都已经到头了的时候，我们发现 <code>Object.prototype</code> 这一原型对象也具有它的 <code>__proto__</code> 属性，这也应证了我说的每一个对象都具有这个属性：</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e5ea852086d4cb4adeaa5dad04419a7~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>展开看一下：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab679ca0bb234e01895a99184341f4c7~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>可以看到它上面有四个简单的属性：<code>arguments</code>、<code>caller</code>、<code>length</code>、<code>name</code>，熟悉函数的同学肯定知道这不是每一个函数上面应该具有的属性吗。</p> <p>这究竟又是怎么回事呢？我们在讨论对象，怎么又跟函数扯上了关系。之前已经说了，所有的函数本质上都是对象，那么 <code>Object</code> 这一构造函数也不例外，它也是通过 <code>new Function</code> 出来的。所以有 <code>Object.__proto__ === Function.prototype</code> ：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f0f76dde134612817543a67683c08f~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>讨论到这里后，我们回到 <code>Person</code> 的例子，<code>Person</code> 这一构造函数也具有原型对象，这一原型对象也是 <code>Object</code> 构造函数的实例对象。</p> <p>所以有 <code>Person.prototype.__proto__ === Object.prototype</code> 这一结论是成立的。</p> <p>那么重点来了，<code>Function</code> 也是一个对象，它和 <code>Object</code> 之前有什么关系呢？</p> <p>首先排除掉 <code>Function</code> 是通过 <code>new Object</code> 出来的这种可能性。因为 <code>Person.prototype</code> 是通过 <code>new Object</code> 出来的，又有<code>Person.__proto__ === Function.prototype</code>。</p> <p>那么 <code>Function.__proto__</code> 到底指向谁呢？其实这里就是 <code>javascript</code> 语言本身的原型闭环。直接上答案：<code>Function.__proto__ === Function.prototype</code>。可以看到这时非常特殊的。</p> <p>距离原型链的顶端 <code>null</code> 就只有两部之遥了，加把劲，我们就要彻底搞清了。</p> <p><code>Function</code> 的原型对象也是一个对象，所以这个原型对象也是 <code>Object</code> 的实例，就有：<code>Function.prototype.__proto__ === Object.prototype</code> 。</p> <p>那么再往上找，<code>Object</code> 的原型对象的 <code>__proto__</code> 就指向 <code>null</code> 了，因为它不可能是 <code>new Object</code> 获得的。这样，整个原型与原型链的机制我们就都摸清楚了。</p> <p>我将上述讲解到的内容做出以下图解，相信你可以理清楚其中所有的脉络：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b62a02c8c9e4f4694d32d129db571ae~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <h2 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h2> <p>学完整个原型链后其实我们也学会了一个运算符 <code>instanceof</code>。</p> <p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上，它的用法很简单，大家可以自行学习，这里继续本文的主题。</p> <p>趁热打铁，我们来探索一下原型与原型链在<strong>社区中的优秀用例</strong>吧。</p> <h2 id="社区中的使用"><a href="#社区中的使用" class="header-anchor">#</a> 社区中的使用</h2> <p>关于原型与原型链在社区中的使用很多，这里我挑选出了两个大家耳熟能详的库和框架中的案例，<code>jQuery</code> 和 <code>Vue</code> 。</p> <p>先让我们来看看在 <code>jQuery</code> 中是怎么巧妙地使用原型机制的。</p> <h3 id="jquery"><a href="#jquery" class="header-anchor">#</a> jQuery</h3> <p><code>jQuery</code> 相信我们每一个人都用过，最早也是它将原型链整个机制发扬光大的。</p> <p>不知道你有没有发现这样一个现象，就是当我们通过 <code>$()</code> 创建出来一个 <code>jQuery</code> 的实例对象的时候，浏览器的控制台中显示的是这样子的：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b263a1511f884ea88402340051f6c121~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>它其实是 <code>jQuery.fn.init</code> 这一构造函数的实例对象，是不是很纳闷，让我们带着疑惑走进 <code>jQuery</code> 的源码进而探究其对原型机制的使用。</p> <p>我们这里仅仅展示一个简单的架子，根据上面的结果，有下面的推测：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">jQuery</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>init</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  jQuery<span class="token punctuation">.</span>fn <span class="token operator">=</span> jQuery<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function-variable function">init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  window<span class="token punctuation">.</span>jQuery <span class="token operator">=</span> window<span class="token punctuation">.</span>$ <span class="token operator">=</span> jQuery<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>相信我们都可以看懂这几行代码吧，这里简单的解释一下：</p> <ul><li>首先整个代码放入一个自执行函数中，避免污染全局变量。</li> <li>内部声明一个名为 <code>jQuery</code> 的函数，最后像全局 <code>window</code> 上挂载 <code>jQuery</code> 和 <code>$</code> 供外部使用。</li> <li>由浏览器中看到的返回的实例对象其实是 <code>jQuery.fn.init</code> 得到 <code>jQuery</code> 内部其实是 <code>new jQuery.fn.init()</code> 来创建实例对象。这里 <code>jQuery.fn</code> 其实是 <code>jQuery.prototype</code> 的一个引用。</li> <li>之后在 <code>jQuery</code> 的原型对象上添加了很多供外部使用的方法，例如 <code>css</code>、<code>html</code>等等。</li></ul> <p>解释完后疑问就随之产生了，为什么我们给 <code>jQuery</code> 的原型对象上添加的方法，<code>jQuery.fn.init</code> 的实例对象却可以访问到呢？</p> <p>正当我们百思不得其解的时候，下面这行代码给了我们答案：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>prototype <span class="token operator">=</span> jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
</code></pre></div><p>这行代码是让<code>jQuery.fn.init</code> 的原型对象指向了 <code>jQuery</code> 的原型对象。这样一来 <code>jQuery.fn.init</code> 的实例对象就可以拿到 <code>jQuery</code> 的原型上的方法，这里给出图解：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a20090f99ee4caab9cc298849398381~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>这一<strong>原型共享</strong>的设计可谓是十分的巧妙。</p> <blockquote><p>想了解更多 <code>jQuery</code> 中的巧妙设计可以私信或者关注我，后续将持续发布相关文章。</p></blockquote> <h3 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h3> <p>了解了 <code>jQuery</code> 中的<strong>共享原型</strong>后，我们再来探索一下在 <code>Vue2.x</code> 中的<strong>代理原型</strong>的设计。</p> <p>在 <code>Vue2.x</code> 的响应式系统中，为了拦截可以改变数组本身的 <code>7</code> 个操作：<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code>、<code>splice</code>、<code>reverse</code>、<code>sort</code>。设计出了代理原型的模式来进行拦截。</p> <p>我们来探究一下其内部是怎么做的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span>
<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  proto<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">拦截到了</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>method<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">方法的执行</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto<span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们来解析一下以上代码：</p> <ul><li>首先 <code>arrayProto</code> 拿到数组原型对象的引用。</li> <li>创建一个 <code>proto</code> 的对象，继承自数组的原型对象，此时 <code>proto</code> 上继承了所有数组原型对象的属性和方法。</li> <li>接着遍历准备好的包含七个方法名称的数组，依次重写 <code>proto</code> 上的这些方法。</li> <li><code>proto</code> 对象上对应的这七个方法分别进行了一次拦截操作，并且内部其实继续使用 <code>call</code> 绑定 <code>this</code> 指向调用了数组原型上的对应的方法。</li> <li>接着我们创建了一个数组，修改其 <code>__proto__</code> 属性指向新创建的对象，之后调用 <code>push</code> 方法。</li></ul> <p>可以在浏览器中看到：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6adb011fff53496c8613959acd4d43f6~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>我们对对应的方法进行了<strong>拦截</strong>，并且<strong>没有破坏数组原来的方法的作用</strong>（这里指添加一个元素）。</p> <p>这就是 <code>Vue2.x</code> 中对原型的高级使用。</p> <blockquote><p>想了解更多关于 <code>Vue2.x</code> 或 <code>Vue3.x</code> 中的响应式原理可以私信或者关注我，后续将持续发布相关文章。</p></blockquote> <h2 id="使用原型"><a href="#使用原型" class="header-anchor">#</a> 使用原型</h2> <p>在了解了优秀的类库或者框架中对原型机制的使用后，我们在日常代码中可以怎么使用这一机制来优化我们的代码呢？</p> <p>这里我将给大家举个例子，例如我们要实现一个数组的去重方法，我们可以这样设计代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">unique</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>之后你只需要这样使用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>
</code></pre></div><p>当然你可以将你的 <code>unique</code> 设计的更为强大，例如可以添加一个回调函数等。</p> <p>但是有一个需要注意的是，如果你想要在项目中使用此类方法，一定要确保这以后不会称为 <code>javascript</code> 的语言规范，不然对于一个长期使用的项目来说会是一个很大的麻烦。例如，上面的 <code>unique</code> 函数以后成为了语言规范（这里只是假设），在你的项目中后面来的新人在维护项目的时候使用了这个方法。因为他不知道你已经修改了原型上的这个方法，会对他们的使用造成很大的困惑。所以我们在项目中使用的时候要注意命名，尽量避免这类问题。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>有关 <code>javascript</code> 语言中的<strong>原型与原型链</strong>机制这里就介绍完毕了，相信弄清楚上面的知识后，有关这部分的问题对你来说再也不会是问题了，你也不需要再回过头来一次又一次的似懂非懂的学习。</p> <p>将一个知识点从使用到原理解读、底层实现、社区如何使用、最后到自己实战中使用经历这些步骤后肯定会对它不再畏惧。最后将所有的知识点总结起来，关联起来就可以形成一个完整的知识体系。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/FXburning/assets/js/app.a5785852.js" defer></script><script src="/FXburning/assets/js/2.ee1c7fd8.js" defer></script><script src="/FXburning/assets/js/9.4187d263.js" defer></script>
  </body>
</html>
